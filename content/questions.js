module.exports = [
  {
    challenge: 1,
    type: 'multiple choice',
    question: 'Which of the following is NOT a property of the Binary Search Tree data structure?',
    options: ['The LEFT subtree of a node contains only nodes with keys LESS than the node’s key.', 'The LEFT subtree of a node contains only nodes with keys GREATER than the node’s key.', 'The RIGHT subtree of a node contains only nodes with keys GREATER than the node’s key.', 'Both the LEFT and RIGHT subtrees must also be binary search trees.'],
    solution: 1,
    hint: "Hash Table definition:\n\n- Stores data with key value pairs.\n- Hash functions accept a key and return an output unique only to that specific key. This is known as hashing, which is the concept that an input and an output have a one-to-one correspondence to map information.\n- Hash functions return a unique address in memory for that data.\n- Designed to optimize searching, insertion, and deletion.\n- Hash collisions are when a hash function returns the same output for two distinct inputs.\n- Hashes are important for associative arrays and database indexing.",
    category: 'binary trees',
    hintImage: 'https://media.giphy.com/media/irTuv1L1T34TC/giphy.gif'
  },
  {
    challenge: 1,
    type: 'order',
    question: 'A single recursion of Pre-order Traversal for a Binary Search Tree called with function preOrder()',
    options: ['Visit the root.', 'Traverse the left subtree, i.e., call preOrder(left-subtree)', 'Traverse the right subtree, i.e., call preOrder(right-subtree)'],
    solution: [1, 2, 3],
    hint: "Depth First Traversals:\n(a) Inorder (Left, Root, Right)\n(b) Preorder (Root, Left, Right)\n(c) Postorder (Left, Right, Root)",
    category: 'Depth-First Traversal',
    hintImage: 'https://media.giphy.com/media/irTuv1L1T34TC/giphy.gif'
  },  
  {
    challenge: 1,
    type: 'multiple choice',
    question: 'What would be the result of the following recursive function?',
    code: "def func(num):\n    if n == 4:\n       return n\n    else:\n       return 2 * func(n+1);\n\nfunc(2)",
    options: ['4', '3', '16', 'infinity'],
    solution: 2,
    hint: "Depth First Traversals:\n(a) Inorder (Left, Root, Right)\n(b) Preorder (Root, Left, Right)\n(c) Postorder (Left, Right, Root)",
    category: 'Depth-First Traversal',
    hintImage: 'https://media.giphy.com/media/irTuv1L1T34TC/giphy.gif'
  },
  {
    challenge: 1,
    type: 'swipe',
    question: "An instance of a pre-order traversal of a BST returns the sequence 39, 30, 10, 17, 33, 23, 40, 34, 50.\n\nIts post-order traversal is 17, 10, 23, 33, 30, 34, 50, 40, 30.",
    code: "",
    options: null,
    solution: true,
    hint: "",
    category: 'Depth-First Traversal',
    hintImage: 'https://media.giphy.com/media/irTuv1L1T34TC/giphy.gif'
  },
  {
    challenge: 1,
    type: 'fill in',
    question: "The following is working code validating a Binary Search Tree in Python.",
    code: "class Solution:\n  def isValidBST(self, root):\n    output = []\n    self.inOrder(root, output)\n    \n    for i in range(1, len(output)):\n      if output[i-1] >= output[i]:\n        return False\n\n    return True\n\n  def inOrder(self, root, output):\n    if root is None:\n      return\n    ____________________________________\n    output.append(root.val)\n    self.inOrder(root.right, output) ",
    options: null,
    solution: "self.inOrder(root.left, output)",
    hint: "",
    category: 'dfs',
    hintImage: ''
  },
  {
    challenge: 2,
    type: "swipe",
    question: "A string is defined as a palindrome if the reversal of the string is equal to the original string.\n\nFor example, “toot” is a palindrome, but “boot” is not.",
    options: [],
    code: '',
    solution: true,
    hint: "",
    category: "strings",
    hintImage: "",
    questionImage: ""
  },
  {
    challenge: 2,
    type: "order",
    question: "Successfully finding out if a string is a palindrome.",
    options: ["Open a while loop to perform while low is less than high", "Continue until end of loop and return true", "Define two variables: high and low, as 0 and (length of string - 1)", "If string[low] does not equal string[high], return false. Increment low, decrement high"],
    code: '',
    solution: [2, 4, 1, 3],
    hint: "",
    category: "strings",
    hintImage: "",
    questionImage: ""
  },  
  {
    challenge: 2,
    type: "multiple choice",
    question: "What will the following code do to an input string?",
    options: ["Make a copy", "Reverse the string", "Swap the first and last letters", "Infinite loop"],
    code: "def reverse_str(str):\n  start = 0\n  end = len(str)-1\n  str_copy = [letter for letter in str]\n  while start < end:\n    temp = str_copy[start]\n    str_copy[start] = str_copy[end]\n    str_copy[end] = temp\n    start += 1\n    end -= 1\n  return \"\".join(str_copy)",
    solution: 1,
    hint: "",
    category: "strings",
    hintImage: "",
    questionImage: ""
  },
  {
    challenge: 2,
    type: "multiple choice",
    question: "What is the run time of the following code?",
    options: ["O(log n)", "O(n)", "O(n log n)", "O(n^2)"],
    code: "def reverse_str(str):\n  start = 0\n  end = len(str)-1\n  str_copy = [letter for letter in str]\n  while start < end:\n    temp = str_copy[start]\n    str_copy[start] = str_copy[end]\n    str_copy[end] = temp\n    start += 1\n    end -= 1\n  return \"\".join(str_copy)",
    solution: 1,
    hint: "",
    category: "strings",
    hintImage: "",
    questionImage: ""
  },
  {
    challenge: 3,
    type: 'swipe',
    question: 'A permutation is defined as an arrangement of elements in a set with regards to order of selection.\n\nGiven a string "abc", permutations include "abc", "acb", "bac", "bca", "cba", and "cab".',
    solution: true,
    hint: "",
    category: 'strings',
    questionImage: ''
  },
  {
    challenge: 3,
    type: 'multiple choice',
    question: 'How does a backtracking algorithm find solutions in programming?',
    options: ['By selecting the most optimal option at each iteration', 'Incrementally building candidates and then abandoning ones as soon as they cannot be valid.', 'Randomly guessing at what the solution is', 'By storing the results of expensive function calls and returning the cached result'],
    solution: 1,
    hint: "",
    category: 'backtracking',
    hintImage: ''
  },
  {
    challenge: 3,
    type: 'order',
    question: "generation of all permutations of a string",
    code: "",
    options: ["Determine string length, return is null or 0", "Keep the first character of the string", "Swap the first character with each of the rest", "Recursively call the algorithm on the rest of the characters"],
    solution: [1, 2, 3 4],
    hint: "",
    category: '',
    hintImage: ''
  },
  {
    challenge: 3,
    type: 'fill in',
    question: 'What missing line would print all permutations of the inputted string?',
    options: [],
    code: "def permutations(str, step = 0):\n    if step == len(str):\n        print(\"\".join(str))\n\n    for i in range(step, len(str)):\n        str_arr = [element for element in str]\n        _______________________________\n        permutations(str_arr, step + 1)",
    solution: "str_arr[step], str_arr[i] = str_arr[i], str_arr[step]",
    hint: "",
    category: "strings",
    hintImage: "",
    questionImage: ""
  },
  {
    challenge: 4,
    type: "multiple choice",
    question: "Given an array of stock prices on an hourly basis throughout a day, calculate the max profit that you can make by buying and selling only once. Which of the following variables may be helpful in solving this problem?",
    options: ["An hourly profit amount", "A maximum and minimum price", "An hourly profit and minimum price", "A daily minimum price"],
    code: "",
    solution: 2,
    hint: "",
    category: "arrays",
    hintImage: "",
    questionImage: ""
  },
  {
    challenge: 4,
    type: "fill in",
    question: "What line would get us the max profit for each day?",
    options: [],
    code: "def maxProfit(self, prices):\n    if len(prices)==0: return 0\n    if len(prices) == 1: return 0\n    curMax = prices[len(prices)-1]\n    maxP = 0\n    for i in range(len(prices)):\n        temp = prices[len(prices)-i-1]\n        _____________\n            curMax = temp\n        curProfit = curMax-temp\n        if curProfit > maxP:\n            maxP = curProfit\n    return maxP",
    solution: "if temp > curMax:",
    hint: "",
    category: "",
    hintImage: "",
    questionImage: ""
  },
  {
    challenge: 4,
    type: "multiple choice",
    question: "What is the time and space complexity of the below algorithm?",
    options: ["O(n) and O(1)", "O(n) and O(n)", "O(1) and O(1)", "O(n^2) and O(n)"],
    code: "def maxProfit(self, prices):\n    if len(prices)==0: return 0\n    if len(prices) == 1: return 0\n    curMax = prices[len(prices)-1]\n    maxP = 0\n    for i in range(len(prices)):\n        temp = prices[len(prices)-i-1]\n        if temp > curMax:\n            curMax = temp\n        curProfit = curMax-temp\n        if curProfit > maxP:\n            maxP = curProfit\n    return maxP",
    solution: 0,
    hint: "",
    category: "",
    hintImage: "",
    questionImage: ""
  },
  {
    challenge: 5,
    type: "order",
    question: "pseudocode for finding a contiguous subarray that sums up to a certain number",
    options: ["O(n) and O(1)", "O(n) and O(n)", "O(1) and O(1)", "O(n^2) and O(n)"],
    code: "def maxProfit(self, prices):\n    if len(prices)==0: return 0\n    if len(prices) == 1: return 0\n    curMax = prices[len(prices)-1]\n    maxP = 0\n    for i in range(len(prices)):\n        temp = prices[len(prices)-i-1]\n        if temp > curMax:\n            curMax = temp\n        curProfit = curMax-temp\n        if curProfit > maxP:\n            maxP = curProfit\n    return maxP",
    solution: 0,
    hint: "",
    category: "",
    hintImage: "",
    questionImage: ""
  },
  {
    challenge: 6,
    type: 'swipe',
    question: 'Recurrence and time complexity for worst case of QuickSort is T(n-1) + O(n) and O(n^2) respectively.',
    solution: true,
    hint: "The worst case of QuickSort occurs when the picked pivot is always one of the corner elements in sorted array. In worst case, QuickSort recursively calls one subproblem with size 0 and other subproblem with size (n-1). So recurrence is T(n) = T(n-1) + T(0) + O(n) The above expression can be rewritten as T(n) = T(n-1) + O(n).",
    category: 'Sorting',
    questionImage: ''
  },
  {
    challenge: 6,
    type: 'order',
    question: 'What is the order of steps in Quick Sort?',
    options: ['Then, apply the quicksort algorithm to the first and the third part. (recursively)', 'Pick a pivot element.', 'Partition the array into 3 parts: all elements in this part is less than the pivot, the pivot, and all elements greater.'],
    solution: [3, 1, 2],
    hint: "",
    category: 'Depth-First Traversal',
    hintImage: 'https://media.giphy.com/media/irTuv1L1T34TC/giphy.gif'
  },
  {
    challenge: 6,
    type: 'multiple choice',
    question: 'Which of the following one of these is the missing step to this algorithm:"\n\n(1) Create a low pointer at the beginning of the array and a high pointer at the end of the array.\n(2) Create a mid pointer that starts at the beginning of the array and iterates through each element.\n(3) _______________\n(4) If the element at arr[mid] is a 0, then swap arr[mid] and arr[low] and increase the low and mid pointers by 1.\n(5) If the element at arr[mid] is a 1, don\'t swap anything and just increase the mid pointer by 1.\n"',
    options: ['If the element at arr[mid] is a 2, then swap arr[mid] and arr[high] and decrease the high pointer by 1.', 'If the element at arr[mid] is a 1, then swap arr[mid] and arr[low] and decrease the low pointer by 1.', 'If the element at arr[low] is a 2, then swap arr[low] and arr[high] and increase the high pointer by 1.'],   
    solution: 'If the element at arr[mid] is a 2, then swap arr[mid] and arr[high] and decrease the high pointer by 1.',
    hint: "Hash Table definition:\n\n- Stores data with key value pairs.\n- Hash functions accept a key and return an output unique only to that specific key. This is known as hashing, which is the concept that an input and an output have a one-to-one correspondence to map information.\n- Hash functions return a unique address in memory for that data.\n- Designed to optimize searching, insertion, and deletion.\n- Hash collisions are when a hash function returns the same output for two distinct inputs.\n- Hashes are important for associative arrays and database indexing.",
    category: 'Sorting',
    hintImage: 'https://media.giphy.com/media/irTuv1L1T34TC/giphy.gif'
  },
    {
    challenge: 7,
    type: 'swipe',
    question: 'The worst case time complexity for search, insert and delete operations in a general Binary Search Tree is O(n).',
    solution: true,
    hint: "Binary search tree (BST):\nA binary tree that uses comparable keys to assign which direction a child is.\n\n- Left child has a key smaller than it's parent node.\n- Right child has a key greater than it's parent node.\n- There can be no duplicate node.\n- Because of the above it is more likely to be used as a data structure than a binary tree.\n\nAverage case Big-O:\nIndexing: O(log n)\nSearch: O(log n)\nInsertion O(log n)",
    category: 'Binary Search Trees',
    questionImage: 'https://upload.wikimedia.org/wikipedia/commons/thumb/f/f7/Binary_tree.svg/192px-Binary_tree.svg.png'
  },
  {
    challenge: 7,
    type: 'order',
    question: 'In-order Traversal for a Binary Search Tree:',
    options: ['Visit the root.', 'Traverse the left subtree, i.e., call Inorder(left-subtree) ', 'Traverse the right subtree, i.e., call Inorder(right-subtree)'],
    solution: ['1. Traverse the left subtree, i.e., call Inorder(left-subtree) ', '2. Visit the root.', '3. Traverse the right subtree, i.e., call Inorder(right-subtree)'],
    hint: "Depth First Traversals:\n(a) Inorder (Left, Root, Right)\n(b) Preorder (Root, Left, Right)\n(c) Postorder (Left, Right, Root)",
    category: 'Depth-First Traversal',
    hintImage: 'https://media.giphy.com/media/irTuv1L1T34TC/giphy.gif'
  },
  {
    challenge: 7,
    type: 'fill in',
    question: "The following is valid code for an inorder traversal in Javascript:\n\nfunction inorder(node){\n   if(node){\n      inorder(node.left);\n      console.log(node.value);\n      _______________\n   }\n}",
    solution: false,
    hint: "The following is valid code for an inorder traversal in Javascript:\n\nfunction inorder(node){\n   if(node){\n      inorder(node.left);\n      console.log(node.value);\n      inorder(node.right);\n   }\n}",
    category: 'Depth-First Traversal',
    hintImage: 'https://media.giphy.com/media/irTuv1L1T34TC/giphy.gif'
  },
  {
    challenge: 7,
    type: 'multiple choice',
    question: 'Which of the following is not an advantage of a hash map data structure?',
    options: ['Being able to lookup data on the order of O(1) independent of the size of the data structure.', 'Being able to insert data on the order of O(1) independent of the size of the data structure.', 'Finding the maximum and minimum keys in O(1).', 'If the set of key-value pairs is fixed and known ahead of time, one may reduce the average lookup cost by a careful choice of the hash function, bucket table size, and internal data structures such that keys need not be stored in the table.'],
    solution: 'Finding the maximum and minimum keys in O(1).',
    hint: "Hash Table definition:\n\n- Stores data with key value pairs.\n- Hash functions accept a key and return an output unique only to that specific key. This is known as hashing, which is the concept that an input and an output have a one-to-one correspondence to map information.\n- Hash functions return a unique address in memory for that data.\n- Designed to optimize searching, insertion, and deletion.\n- Hash collisions are when a hash function returns the same output for two distinct inputs.\n- Hashes are important for associative arrays and database indexing.",
    category: 'Hash Tables',
    hintImage: 'https://media.giphy.com/media/irTuv1L1T34TC/giphy.gif'
  },
  {
    challenge: 7,
    type: 'swipe',
    question: 'How would you find all the pairs of two integers in an unsorted array that sum up to a given S?\n\nFor example, if the array is [3, 5, 2, -4, 8, 11] and the sum is 7, your program should return [[11, -4], [2, 5]] because 11 + -4 = 7 and 2 + 5 = 7.',
    code: 'twoSum(int[] nums, int target)\n  map = {}\n  iterate through nums\n    difference = target - nums[i]\n    if map.contains difference\n      return [map.get(complement), i];\n    }\n    map.put(nums[i], i);',
    solution: true,
    hint: "function twoSum(arr, S) {\n\n  var sums = [];\n  var hashTable = {};\n  for (var i = 0; i < arr.length; i++) {\n    var difference = S - arr[i];\n    if (hashTable.hasOwnProperty(difference)) { \n      sums.push([arr[i], difference]);\n    }\n    hashTable[arr[i].toString()] = arr[i];\n\n  }\n  return sums;\n\n}",
    category: 'Two Sum',
    hintImage: 'https://media.giphy.com/media/irTuv1L1T34TC/giphy.gif'
  },
  {
    challenge: 7,
    type: 'order',
    question: 'Given the root of a binary search tree, and a target K, return two nodes in the tree whose sum equals K. Select the order to accomplish this in O(n) time and O(n) space.',
    options: ['Create a hash map', 'Create an auxiliary array', 'Push an inorder traversal of the BST nodes into the auxiliary array', 'Iterate through each node in the auxiliary array, checking for the difference from the target in the hash map, and returning if found'],
    solution: ['1. Create an auxiliary array', '2. Push an inorder traversal of the BST nodes into the auxiliary array', '3. Create a hash map', '4. Iterate through each node in the auxiliary array, checking for the difference from the target in the hash map, and returning if found'],
    hint: "function twoSum(arr, S) {\n\n  var sums = [];\n  var hashTable = {};\n  for (var i = 0; i < arr.length; i++) {\n    var difference = S - arr[i];\n    if (hashTable.hasOwnProperty(difference)) { \n      sums.push([arr[i], difference]);\n    }\n    hashTable[arr[i].toString()] = arr[i];\n\n  }\n  return sums;\n\n}",
    category: 'Two Sum',
    hintImage: 'https://media.giphy.com/media/irTuv1L1T34TC/giphy.gif'
  },
  {
    challenge: 0,
    type: "",
    question: "",
    options: [],
    code: "",
    solution: "",
    hint: "",
    category: "",
    hintImage: "",
    questionImage: ""
  }
];
